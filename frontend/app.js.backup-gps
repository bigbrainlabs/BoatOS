/**
 * BoatOS Frontend - Marine Dashboard
 */

const API_URL = window.location.hostname === 'localhost'
    ? 'http://localhost:8000'
    : `http://${window.location.hostname}:8000`;

const WS_URL = window.location.hostname === 'localhost'
    ? 'ws://localhost:8000/ws'
    : `ws://${window.location.hostname}:8000/ws`;

// ==================== STATE ====================
let map;
let boatMarker;
let waypoints = [];
let routeLayer;
let currentPosition = { lat: 50.8, lon: 5.6 }; // Default: Albertkanal
let ws;
let routePlanningMode = false;
let weatherData = null;

// ==================== MAP INIT ====================
function initMap() {
    // Karte initialisieren
    map = L.map('map', {
        zoomControl: false,
        attributionControl: false
    }).setView([currentPosition.lat, currentPosition.lon], 13);

    // OpenSeaMap Tiles
    L.tileLayer('https://tiles.openseamap.org/seamark/{z}/{x}/{y}.png', {
        maxZoom: 18
    }).addTo(map);

    // Base Map (OpenStreetMap)
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19
    }).addTo(map);

    // Zoom Control (rechts unten)
    L.control.zoom({ position: 'bottomleft' }).addTo(map);

    // Boot-Position Marker
    boatMarker = L.marker([currentPosition.lat, currentPosition.lon], {
        icon: L.divIcon({
            className: 'boat-marker',
            iconSize: [30, 30]
        })
    }).addTo(map);

    // Route Layer
    routeLayer = L.layerGroup().addTo(map);

    // Click Handler f√ºr Wegpunkte
    map.on('click', onMapClick);

    console.log('‚úÖ Map initialized');
}

// ==================== WEBSOCKET ====================
function connectWebSocket() {
    ws = new WebSocket(WS_URL);

    ws.onopen = () => {
        console.log('‚úÖ WebSocket connected');
        document.getElementById('signalk-status').classList.add('connected');
    };

    ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        updateSensorDisplay(data);
        updateBoatPosition(data.gps);
    };

    ws.onerror = (error) => {
        console.error('‚ùå WebSocket error:', error);
        document.getElementById('signalk-status').classList.remove('connected');
    };

    ws.onclose = () => {
        console.log('‚ö†Ô∏è WebSocket disconnected, reconnecting...');
        document.getElementById('signalk-status').classList.remove('connected');
        setTimeout(connectWebSocket, 3000);
    };
}

// ==================== SENSOR UPDATES ====================
function updateSensorDisplay(data) {
    // Speed
    if (data.speed !== undefined) {
        document.getElementById('speed').innerHTML =
            `${data.speed.toFixed(1)}<span class="tile-unit">kn</span>`;
    }

    // Heading
    if (data.heading !== undefined) {
        document.getElementById('heading').innerHTML =
            `${Math.round(data.heading)}<span class="tile-unit">¬∞</span>`;
    }

    // Depth
    if (data.depth !== undefined) {
        document.getElementById('depth').innerHTML =
            `${data.depth.toFixed(1)}<span class="tile-unit">m</span>`;
    }

    // Wind
    if (data.wind && data.wind.speed !== undefined) {
        document.getElementById('wind').innerHTML =
            `${data.wind.speed.toFixed(0)}<span class="tile-unit">kn</span>`;
    }
}

function updateBoatPosition(gps) {
    if (gps && gps.lat && gps.lon) {
        currentPosition = { lat: gps.lat, lon: gps.lon };

        // Marker aktualisieren
        boatMarker.setLatLng([gps.lat, gps.lon]);

        // GPS Status
        document.getElementById('gps-status').classList.add('connected');

        // Karte folgt Boot (optional - nur wenn nicht manuell gezoomt)
        // map.setView([gps.lat, gps.lon], map.getZoom());
    }
}

// ==================== WEGPUNKTE ====================
function onMapClick(e) {
    if (!routePlanningMode) return;

    const waypoint = {
        lat: e.latlng.lat,
        lon: e.latlng.lng,
        name: `WP${waypoints.length + 1}`,
        timestamp: new Date().toISOString()
    };

    addWaypoint(waypoint);
}

function addWaypoint(waypoint) {
    // Marker auf Karte
    const marker = L.marker([waypoint.lat, waypoint.lon], {
        icon: L.divIcon({
            className: 'waypoint-marker',
            html: `<div style="color: white; font-size: 10px; text-align: center; margin-top: 22px;">${waypoint.name}</div>`,
            iconSize: [20, 20]
        }),
        draggable: true
    }).addTo(routeLayer);

    marker.on('drag', () => {
        updateRoute();
    });

    marker.on('click', () => {
        if (confirm(`Wegpunkt ${waypoint.name} l√∂schen?`)) {
            routeLayer.removeLayer(marker);
            waypoints = waypoints.filter(w => w.name !== waypoint.name);
            updateRoute();
        }
    });

    waypoints.push({ ...waypoint, marker });

    // An Backend senden
    fetch(`${API_URL}/api/waypoints`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(waypoint)
    });

    updateRoute();
}

function updateRoute() {
    // Alte Route l√∂schen
    routeLayer.eachLayer(layer => {
        if (layer instanceof L.Polyline) {
            routeLayer.removeLayer(layer);
        }
    });

    if (waypoints.length < 2) return;

    // Route zeichnen
    const points = waypoints.map(w => [w.lat, w.lon]);
    L.polyline(points, {
        color: '#3498db',
        weight: 4,
        dashArray: '10, 5'
    }).addTo(routeLayer);

    // Distanz berechnen
    let totalDistance = 0;
    for (let i = 0; i < waypoints.length - 1; i++) {
        const from = L.latLng(waypoints[i].lat, waypoints[i].lon);
        const to = L.latLng(waypoints[i + 1].lat, waypoints[i + 1].lon);
        totalDistance += from.distanceTo(to);
    }

    console.log(`üìè Route Distanz: ${(totalDistance / 1852).toFixed(2)} NM`);
}

// ==================== WEATHER ====================
async function fetchWeather() {
    try {
        const lang = getLanguage ? getLanguage() : 'de';
        const response = await fetch(`${API_URL}/api/weather?lang=${lang}`);
        if (response.ok) {
            weatherData = await response.json();
            updateWeatherDisplay();
            console.log('‚úÖ Weather data loaded:', weatherData);
        }
    } catch (error) {
        console.error('‚ùå Weather fetch failed:', error);
    }
}

function updateWeatherDisplay() {
    if (!weatherData || !weatherData.current) return;

    const current = weatherData.current;

    // Update Weather Tile
    document.getElementById('weather-temp').textContent = current.temp.toFixed(1);
    document.getElementById('weather-desc').textContent = current.description;
    document.getElementById('weather-icon').src = `https://openweathermap.org/img/wn/${current.icon}@2x.png`;

    // Update Wind im Wind-Tile (falls vorhanden)
    if (current.wind_speed !== undefined) {
        document.getElementById('wind').innerHTML =
            `${current.wind_speed.toFixed(0)}<span class="tile-unit">kn</span>`;
    }
}

function toggleWeatherPanel() {
    const panel = document.getElementById('weather-panel');
    if (panel.style.display === 'none' || !panel.style.display) {
        panel.style.display = 'block';
        updateWeatherPanel();
    } else {
        panel.style.display = 'none';
    }
}

function updateWeatherPanel() {
    if (!weatherData || !weatherData.current) return;

    const current = weatherData.current;

    // Current Weather Details
    document.getElementById('weather-panel-temp').textContent = `${current.temp.toFixed(1)}¬∞C`;
    document.getElementById('weather-panel-feels').textContent = `Feels like: ${current.feels_like.toFixed(1)}¬∞C`;
    document.getElementById('weather-panel-desc').textContent = current.description;
    document.getElementById('weather-panel-wind').textContent = `Wind: ${current.wind_speed.toFixed(1)} kn`;
    document.getElementById('weather-panel-pressure').textContent = `Pressure: ${current.pressure} hPa`;
    document.getElementById('weather-panel-humidity').textContent = `Humidity: ${current.humidity}%`;
    document.getElementById('weather-panel-visibility').textContent = `Visibility: ${current.visibility.toFixed(1)} NM`;
    document.getElementById('weather-panel-clouds').textContent = `Clouds: ${current.clouds}%`;

    // Forecast
    const forecastHtml = weatherData.forecast.map(f => `
        <div class="forecast-item">
            <div class="forecast-date">${f.date}</div>
            <img src="https://openweathermap.org/img/wn/${f.icon}.png" alt="${f.description}" style="width:50px">
            <div class="forecast-temp">${f.temp.toFixed(1)}¬∞C</div>
            <div class="forecast-wind">${f.wind_speed.toFixed(0)} kn</div>
        </div>
    `).join('');

    document.getElementById('weather-forecast').innerHTML = forecastHtml;
}

// ==================== CONTROLS ====================
document.getElementById('btn-waypoint').addEventListener('click', () => {
    // Wegpunkt an aktueller Boot-Position
    addWaypoint({
        lat: currentPosition.lat,
        lon: currentPosition.lon,
        name: `WP${waypoints.length + 1}`,
        timestamp: new Date().toISOString()
    });

    showNotification('üìç Wegpunkt gesetzt');
});

document.getElementById('btn-route').addEventListener('click', (e) => {
    routePlanningMode = !routePlanningMode;
    e.target.classList.toggle('active');

    if (routePlanningMode) {
        showNotification('üõ§Ô∏è Routenplanung aktiv - Tippe auf Karte f√ºr Wegpunkte');
    } else {
        showNotification('üõ§Ô∏è Routenplanung beendet');

        // Route speichern
        if (waypoints.length > 0) {
            saveRoute();
        }
    }
});

document.getElementById('btn-logbook').addEventListener('click', () => {
    openLogbook();
});

document.getElementById('btn-sensors').addEventListener('click', () => {
    showNotification('üìä Sensor-Details - Coming soon!');
    // TODO: Sensor-Details-Modal √∂ffnen
});

function saveRoute() {
    const route = {
        name: `Route ${new Date().toLocaleDateString('de-DE')}`,
        waypoints: waypoints.map(w => ({
            lat: w.lat,
            lon: w.lon,
            name: w.name
        })),
        timestamp: new Date().toISOString()
    };

    fetch(`${API_URL}/api/routes`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(route)
    })
    .then(res => res.json())
    .then(data => {
        console.log('‚úÖ Route gespeichert:', data);
        showNotification('üíæ Route gespeichert');
    })
    .catch(err => {
        console.error('‚ùå Route speichern fehlgeschlagen:', err);
    });
}

// ==================== NOTIFICATIONS ====================
function showNotification(message) {
    // Simple Toast-Notification
    const toast = document.createElement('div');
    toast.style.cssText = `
        position: fixed;
        top: 80px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(46, 204, 113, 0.95);
        color: white;
        padding: 15px 30px;
        border-radius: 8px;
        font-size: 16px;
        font-weight: 600;
        z-index: 10000;
        box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    `;
    toast.textContent = message;
    document.body.appendChild(toast);

    setTimeout(() => {
        toast.style.opacity = '0';
        toast.style.transition = 'opacity 0.5s';
        setTimeout(() => toast.remove(), 500);
    }, 2000);
}

// ==================== STARTUP ====================
window.addEventListener('load', () => {
    initMap();
    connectWebSocket();

    // Weather laden und alle 30min aktualisieren
    fetchWeather();
    setInterval(fetchWeather, 1800000); // 30 min

    // Geolocation API (Browser GPS als Fallback)
    if (navigator.geolocation) {
        navigator.geolocation.watchPosition(
            (position) => {
                // Nur nutzen wenn SignalK keine Daten liefert
                if (!currentPosition.lat || currentPosition.lat === 50.8) {
                    updateBoatPosition({
                        lat: position.coords.latitude,
                        lon: position.coords.longitude
                    });
                }
            },
            (error) => console.warn('‚ö†Ô∏è Geolocation error:', error),
            { enableHighAccuracy: true }
        );
    }

    console.log('üö¢ BoatOS Frontend started!');
});

// ==================== SERVICE WORKER (PWA) ====================
if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/sw.js')
        .then(reg => console.log('‚úÖ Service Worker registered'))
        .catch(err => console.log('‚ö†Ô∏è Service Worker registration failed:', err));
}
